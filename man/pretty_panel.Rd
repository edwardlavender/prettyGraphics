% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pretty_panel.R
\name{pretty_panel}
\alias{pretty_panel}
\title{Pretty grouped, multi-panel plots}
\usage{
pretty_panel(
  x,
  y,
  by,
  data = NULL,
  xlim = NULL,
  ylim = NULL,
  pretty_axis_args = list(side = 1:2, control_axis = list(tck = 0.025, las = TRUE)),
  add_xlab = NULL,
  add_ylab = NULL,
  add_main = NULL,
  add_additional = NULL,
  par_param = NULL,
  by_row = TRUE,
  ...
)
}
\arguments{
\item{x, y, by}{Vectors that define point coordinates (\code{x, y}) and a grouping variable (\code{by}).}

\item{data}{(optional) A dataframe that contains additional information (see \code{add_additional}).}

\item{xlim, ylim, pretty_axis_args}{Axis controls. \code{xlim} and \code{ylim} control axis limits for all plots. \code{pretty_axis_args} is a named list of arguments, passed to \code{\link[prettyGraphics]{pretty_axis}}, for further control.}

\item{add_xlab, add_ylab, add_main}{(optional) Named lists of arguments, passed to \code{\link[graphics]{mtext}}, to add axis titles to plots. Panel titles are added to each panel, while only  global labels are added for the x and y axes. Empty lists specify default arguments. In this case, panel titles are given as capitalised letters or numbers (if there are more than 26 predictors), in bold, plus the grouping level in brackets; e.g., \strong{A} (Group One) or \strong{1} (Group One). X and y axis labels are simply given as \code{x} and \code{y}. Alternatively, names can be specified via the `text' argument to \code{\link[graphics]{mtext}}. \code{NULL} suppress these arguments.}

\item{add_additional}{A function used to add additional elements to each panel. This must accept two arguments, even if they are ignored: (1) a list of axis parameters (from \code{\link[prettyGraphics]{pretty_axis}}) and (2) the group-specific dataframe (see examples).}

\item{par_param}{A list of arguments for \code{\link[graphics]{par}} to customise the plotting window. If unsupplied, default settings defined inside the function are used.}

\item{by_row}{A logical variable that defines whether to order panels by row (\code{TRUE}) or column (\code{FALSE}).}

\item{...}{Additional arguments passed to \code{\link[prettyGraphics]{pretty_plot}}.}
}
\value{
The function produces a multi-panel plot.
}
\description{
This function creates pretty multi-panel plots of \code{y} ~ \code{x} split by a grouping variable (\code{by}).
}
\examples{
#### Example (1): Implement function using default options
pretty_panel(iris$Sepal.Length, iris$Sepal.Width, iris$Species)

#### Example (2): Control axes via pretty_axis_args, xlim and ylim
pretty_panel(iris$Sepal.Length, iris$Sepal.Width, iris$Species,
             pretty_axis_args = list(side = 1:4),
             by_row = FALSE)

#### Example (3): Control par via par_param and by_row
## Example using par
pretty_panel(iris$Sepal.Length, iris$Sepal.Width, iris$Species,
             par_param = list(oma = rep(6, 4)))

\dontrun{
# Par arguments are reset unless supplied via par_param,
# ... so the following does not (currently) work:
pp <- graphics::par(oma = rep(6, 4))
pretty_panel(iris$Sepal.Length, iris$Sepal.Width, iris$Species)
graphics::par(pp)
}

## Example with by_row
pretty_panel(iris$Sepal.Length, iris$Sepal.Width, iris$Species,
             by_row = FALSE)

#### Example (4): Add titles
pretty_panel(iris$Sepal.Length, iris$Sepal.Width, iris$Species,
             add_xlab = list(text = "Length", line = 2),
             add_ylab = list(text = "Width", line = 2),
             add_main = list(adj = 0))

#### Example (5): Use add_additional(...) and ... to add additional elements
## Scenario: We will plot predictions from a model of sepal width ~ length for each spp
# Fit model
mod <- lm(Sepal.Width ~ Sepal.Length * Species, data = iris)
# Define function to add predictions that depends on:
# ... axis parameters
# ... group- (species-) specific data
add_pred <- function(.axis_ls = NULL, .data){
  n    <- 100
  xlim <- range(.data$Sepal.Length)
  nd <- data.frame(Sepal.Length = seq(xlim[1], xlim[2], length.out = n),
                   Species = factor(rep(.data$Species[1], n),
                                    levels = levels(iris$Species)))
  p <- predict(mod, newdata = nd, se.fit = TRUE)
  ci <- list_CIs(p)
  add_error_envelope(x = nd$Sepal.Length, ci = ci)
  points(.data$Sepal.Length, .data$Sepal.Width)
}
# Make plot
pretty_panel(iris$Sepal.Length, iris$Sepal.Width, iris$Species,
             data = iris,
             add_additional = add_pred,
             type = "n")

}
\author{
Edward Lavender
}
