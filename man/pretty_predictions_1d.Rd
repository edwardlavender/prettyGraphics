% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pretty_preds.R
\name{pretty_predictions_1d}
\alias{pretty_predictions_1d}
\title{Pretty one-dimensional predictions}
\usage{
pretty_predictions_1d(
  model,
  data = NULL,
  newdata = NULL,
  constants = NULL,
  x_var = NULL,
  n_pred = 100,
  average = mean,
  extract_fit = function(p) p$fit,
  extract_se = function(p) p$se.fit,
  transform_x = NULL,
  xlim = NULL,
  ylim = NULL,
  ylim_fix = TRUE,
  pretty_axis_args = list(),
  add_points = list(cex = 0.5, lwd = 0.5, col = "grey20"),
  add_error_bars = list(add_fit = list(pch = 3)),
  add_error_envelope = list(),
  add_order = c("predictions", "points"),
  add_xlab = list(line = 2.5),
  add_ylab = list(line = 2.5),
  add_main = list(adj = 0, font = 2),
  one_page = TRUE,
  ...
)
}
\arguments{
\item{model}{A model (e.g. an output from \code{\link[mgcv]{gam}}).}

\item{data}{(optional) The dataframe used to fit the model. If missing, this is extracted via \code{model.frame(model)}; however, this approach may fail if functions (e.g., \code{\link[base]{scale}}) have been applied to variables as part of the model formula.}

\item{x_var, n_pred, average, newdata, constants}{(optional) Prediction controls.
\itemize{
  \item \code{x_var} is a character variable that defines the name(s) of  predictors for which to plot predictions. If unsupplied, predictions are plotted for each predictor in the \code{model}.
  \item \code{n_pred} is a number that defines, for continuous predictors, the prediction resolution. For each continuous predictor, a sequence of values from the minimum to maximum value for that variable, with \code{n_pred} elements, is used for prediction. (For factors, predictions are plotted for each factor level.) Alternatively, \code{newdata} can be supplied.
  \item \code{average} is a function that is used to define the value at which doubles are held constant for prediction. The default is \code{\link[base]{mean}}.
  \item \code{newdata} is a dataframe that contains the data used for prediction. If supplied, this should contain one variable that changes in value (defined in \code{x_var}), with other variables held at selected values. If supplied, this supersedes \code{constants} (see below).
  \item \code{constants} is a one-row dataframe of constant values for explanatory variables. If supplied, \code{n_pred} model predictions are generated for \code{x_var}, while holding other variables constant at the values specified in \code{constants}.
  }}

\item{extract_fit, extract_se}{Functions that extract fitted values and standard errors, respectively, from the object returned by \code{\link[stats]{predict}}.}

\item{transform_x}{A function to transform values of the predictor(s) for plotting.}

\item{xlim, ylim, ylim_fix, pretty_axis_args}{Axis controls. \code{xlim} and \code{ylim} control axis limits for all plots. If unsupplied, pretty limits are used. If pretty limits are used, \code{ylim_fix} is a logical variable that defines whether or not to use the same y-axis limits on all plots (\code{TRUE}), which can facilitate comparisons, or to use plot-specific limits (\code{FALSE}). \code{pretty_axis_args} is a named list of arguments, passed to \code{\link[prettyGraphics]{pretty_axis}}, for further control.}

\item{add_points}{(optional) A named list of arguments, passed to \code{\link[graphics]{points}}, to customise observations added to plots. An empty list specifies default options. \code{NULL} suppresses this argument.}

\item{add_error_bars, add_error_envelope}{(optional) Named lists of arguments, passed to \code{\link[prettyGraphics]{add_error_bars}} and \code{\link[prettyGraphics]{add_error_envelope}}, to customise the appearance of error bars (for factor predictors) or envelopes (for continuous predictors) respectively. Empty lists specify default options. \code{NULL} suppresses these arguments.}

\item{add_order}{A character vector that defines the order in which you want to add \code{predictions} and \code{points}. By default, predictions are added first, since these often mask points otherwise. However, this order is reversible.}

\item{add_xlab, add_ylab, add_main}{(optional) Named lists of arguments, passed to \code{\link[graphics]{mtext}}, to add axis titles to plots. X-axis labels and plot titles are added to each plot, while only one global y-axis label is added. Empty lists specify default arguments, in which case variable names are taken as specified in the \code{model} and plot titles are given as capitalised letters or numbers in square brackets (if there are more than 26 predictors). Alternatively, names can be specified via the `text' argument to \code{\link[graphics]{mtext}}. For \code{add_xlab} and \code{add_main} , the `text' argument can be a vector with one element for each plot; for \code{add_ylab} only one element should be supplied. \code{NULL} suppress these arguments.}

\item{one_page}{A logical variable that defines whether or not to plot all plots on one page.}

\item{...}{Additional arguments passed to \code{\link[prettyGraphics]{pretty_plot}}.}
}
\value{
The function plots predictions from a model. A list of axis parameters, with one element (from \code{\link[prettyGraphics]{pretty_axis}}) for each variable, is returned invisibly.
}
\description{
This function plots pretty one-dimensional predictions from a statistical \code{model}. Given a \code{model}, for each predictor, the function plots the predicted values of the response and associated 95 percent confidence intervals. Other predictors are held at the first level (for factors) or an average (e.g., mean or median, as specified) value (for doubles) or at custom values specified in a dataframe called \code{newdata}.
}
\details{
Interactions are not currently supported.
}
\examples{
#### Define a model for predictions
mod_1 <- stats::lm(Sepal.Length ~ Sepal.Width + Species, data = iris)
summary(mod_1)

#### Example (1): Plot predictions using default options
pretty_predictions_1d(mod_1)

#### Example (2): Plot predictions for specified variables
pretty_predictions_1d(mod_1, x_var = c("Sepal.Width"))
pretty_predictions_1d(mod_1, x_var = c("Sepal.Width", "Species"))

#### Example (3): Plot predictions using custom newdata
p_dat <- data.frame(Sepal.Width = median(iris$Sepal.Width),
                    Species = factor(levels(iris$Species),
                                     levels = levels(iris$Species)))
pretty_predictions_1d(mod_1,
                      x_var = "Species",
                      newdata = p_dat)
# Or use constants to use custom constants but standard values for x_var
pretty_predictions_1d(mod_1,
                      constants = data.frame(Sepal.Width = 3),
                      x_var = "Species")

#### Example (4): Customise uncertainty
pretty_predictions_1d(mod_1,
                      add_error_bars = list(cex = 5, bg = "black"),
                      add_error_envelope = list(type = "lines"))

#### Example (5): Customise axes
pretty_predictions_1d(mod_1,
                      ylim = c(NA, 10))
pretty_predictions_1d(mod_1,
                      ylim_fix = FALSE)
pretty_predictions_1d(mod_1,
                      pretty_axis_args = list(control_digits = 2))

#### Example (6): Customise titles
pretty_predictions_1d(mod_1,
                      add_xlab = list(text = c("Width", "Species"), line = 2),
                      add_ylab = list(line = -2),
                      add_main = NULL)

#### Example (7) Back transformations
# The function can be implemented with tranformed variables, but note:
# * Transformations must be applied to the dataframe used to fit the model
# ... (and not in the model fitting function);
# * Transformations should not change variable types (e.g. scale() transforms
# ... numbers into matrices, and this is not permitted).
# * All numeric variables are affected by transform_x

## (A) Scale variable and plot predictions on transformed scale
# Define function to scale numbers that doesn't change variable types
scale_num <- function(x) {
  y <- scale(x)
  attributes(y)$dim <- NULL
  y
}
# Scale Sepal.Width
iris$Sepal.Width.S <- scale_num(iris$Sepal.Width)
# Implement model
mod_2 <- stats::lm(Sepal.Length ~ Sepal.Width.S + Species, data = iris)
# Visualise predictions
pretty_predictions_1d(mod_2)

## (B) Back-transform predictions
unscale <- function(x) {
  mu      <- attr(x, "scaled:center")
  sigma   <- attr(x, "scaled:scale")
  x * sigma + mu
}
pretty_predictions_1d(mod_2, transform_x = unscale)

}
\seealso{
\code{\link[prettyGraphics]{pretty_predictions_2d}}
}
\author{
Edward Lavender
}
